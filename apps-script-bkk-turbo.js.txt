// GOOGLE APPS SCRIPT - BKK INTEGRATED TURBO V11.5 (FIXED LOGIC)

function doGet(e) {
  var action = e.parameter.action || "getData";
  var ssId = "17rIBNXdJOQkuizl_gJ5jGid7oqiEfJdWxUgPtz-i3As";
  
  try {
    if (action === "getDowntimeQuery") {
      return getDowntimeQuery(ssId, e);
    } 
    else if (action === "debugRaw") {
      return debugRawData(ssId, e);
    }
    else {
      return getOutstandingBKKTurbo(ssId, e);
    }
  } catch (err) {
    return createOutput({error: err.toString(), status: "error"}, e);
  }
}

/**
 * DEBUG: Dump raw cell values, types, and headers from DOWNTIME sheet
 */
function debugRawData(ssId, e) {
  var ss = SpreadsheetApp.openById(ssId);
  var sheet = ss.getSheetByName("DOWNTIME");
  var lastRow = sheet.getLastRow();
  var lastCol = sheet.getLastColumn();
  
  var headerRange = sheet.getRange(1, 1, Math.min(5, lastRow), Math.min(lastCol, 25));
  var headers = headerRange.getValues();
  
  var sampleStart = 5;
  var sampleCount = Math.min(5, lastRow - sampleStart + 1);
  var sampleRows = [];
  if (sampleCount > 0) {
    var rawSample = sheet.getRange(sampleStart, 1, sampleCount, Math.min(lastCol, 25)).getValues();
    for (var i = 0; i < rawSample.length; i++) {
      var row = [];
      for (var j = 0; j < rawSample[i].length; j++) {
        var cell = rawSample[i][j];
        row.push({
          col: j,
          val: cell instanceof Date ? cell.toISOString() : String(cell),
          type: cell instanceof Date ? "Date" : typeof cell
        });
      }
      sampleRows.push(row);
    }
  }
  
  return createOutput({
    lastRow: lastRow,
    lastCol: lastCol,
    headers: headers.map(function(r) { return r.map(String); }),
    sampleRows: sampleRows
  }, e);
}

/**
 * ROBUST DATE PARSER (V7.4 ORIGINAL)
 */
function parseDate(val) {
  if (!val) return null;
  if (val instanceof Date) {
    if (isNaN(val.getTime())) return null;
    return val;
  }
  var s = val.toString().trim();
  if (!s || s === "-" || s === "0") return null;
  var m1 = s.match(/^(\d{1,2})[\/\-\.](\d{1,2})[\/\-\.](\d{4})$/);
  if (m1) {
    var day = parseInt(m1[1], 10);
    var mon = parseInt(m1[2], 10);
    var yr  = parseInt(m1[3], 10);
    if (mon >= 1 && mon <= 12 && day >= 1 && day <= 31 && yr >= 2000) {
      return new Date(yr, mon - 1, day);
    }
  }
  var m2 = s.match(/^(\d{4})[\/\-](\d{1,2})[\/\-](\d{1,2})$/);
  if (m2) {
    var yr2  = parseInt(m2[1], 10);
    var mon2 = parseInt(m2[2], 10);
    var day2 = parseInt(m2[3], 10);
    if (mon2 >= 1 && mon2 <= 12 && day2 >= 1 && day2 <= 31 && yr2 >= 2000) {
      return new Date(yr2, mon2 - 1, day2);
    }
  }
  var num = parseFloat(s);
  if (!isNaN(num) && num > 40000 && num < 60000) {
    var epoch = new Date(1899, 11, 30);
    epoch.setDate(epoch.getDate() + num);
    return epoch;
  }
  var d = new Date(s);
  if (!isNaN(d.getTime()) && d.getFullYear() >= 2000) return d;
  return null;
}

/**
 * ROBUST NETTO PARSER (V7.4 ORIGINAL)
 */
function parseNetto(val) {
  if (val === null || val === undefined || val === "" || val === "-") return 0;
  if (typeof val === "number") return val;
  var s = val.toString().trim().replace(/\s/g, "");
  if (!s) return 0;
  var hasDot   = s.indexOf(".") !== -1;
  var hasComma = s.indexOf(",") !== -1;
  if (hasDot && hasComma) {
    var lastDot   = s.lastIndexOf(".");
    var lastComma = s.lastIndexOf(",");
    if (lastComma > lastDot) s = s.replace(/\./g, "").replace(",", ".");
    else s = s.replace(/,/g, "");
  } else if (hasComma && !hasDot) {
    var parts = s.split(",");
    if (parts.length === 2 && parts[1].length === 3) s = s.replace(/,/g, "");
    else s = s.replace(",", ".");
  } else if (hasDot && !hasComma) {
    var dotParts = s.split(".");
    if (dotParts.length === 2 && dotParts[1].length === 3 && dotParts[0].length >= 2) s = s.replace(/\./g, "");
    else if (dotParts.length > 2) s = s.replace(/\./g, "");
  }
  var result = parseFloat(s);
  return isNaN(result) ? 0 : result;
}

/**
 * ROBUST TIME/DURATION PARSER (V12.5)
 */
function parseTime(t) {
  if (t === null || t === undefined || t === "" || t === "-" || t === "0" || t === 0) return 0;
  
  if (t instanceof Date) {
    if (isNaN(t.getTime())) return 0;
    // Google Sheets durations are often Date objects starting from 1899-12-30
    // We care about the time relative to the start of the day
    return (t.getHours() * 60) + t.getMinutes() + (t.getSeconds() / 60);
  }
  
  if (typeof t === "number") {
    // If it's a small number (< 1), it's likely a day fraction from a duration cell
    if (t > 0 && t <= 1) return t * 1440;
    // Otherwise treat as SECONDS (as per user's earlier specification for Manuver/QC)
    return t; // Default to minutes
  }
  
  var str = t.toString().trim();
  if (!str) return 0;
  if (str.indexOf(":") !== -1) {
    var parts = str.split(":");
    var h = parseFloat(parts[0]) || 0;
    var m = parseFloat(parts[1]) || 0;
    var s = parts.length > 2 ? (parseFloat(parts[2]) || 0) : 0;
    return (h * 60) + m + (s / 60);
  }
  
  var num = parseFloat(str.replace(",", "."));
  return isNaN(num) ? 0 : num; // Default to minutes
}

function getDowntimeQuery(ssId, e) {
  var ss = SpreadsheetApp.openById(ssId);
  var sheet = ss.getSheetByName("DOWNTIME");
  
  var targetMonth = parseInt(e.parameter.month); 
  var targetYear = parseInt(e.parameter.year);   
  var matFilter = (e.parameter.material || "").toUpperCase();
  var lastRow = sheet.getLastRow();
  var totalRowsToScan = Math.min(10000, lastRow - 5 + 1); 
  var startRow = Math.max(5, lastRow - totalRowsToScan + 1);
  
  if (totalRowsToScan <= 0) return createOutput({data: [], materials: [], status: "empty_sheet"}, e);

  var rawData = sheet.getRange(startRow, 1, totalRowsToScan, 25).getValues();
  var dailyAgg = {}; 
  var materials = new Set();
  
  // ======== V11.5 SEPARATED COLLECTORS ========
  var materialNetto = {};   
  var intakeTruckTypes = {}; // V11.5: Clean separation
  var directTruckTypes = {}; // V11.5: Clean separation
  var intake71Trucks = [];  // for idle gap analysis
  var i71TotalNetto = 0;
  var i71TotalMan = 0;      
  var i71TotalQC = 0;       
  var i71TruckCount = 0;
  var i71MaterialNetto = {};
  var i71ActiveTotalGenerated = 0; 
  var i71MinSpeed = 9999;
  var i71MaxSpeed = 0;
  var i71TotalSpeedSum = 0;
  var i71SpeedValidCount = 0;
  var intakeSubTypes = {};  // V14: TILTING vs MANUAL breakdown
  var i71DailyDetail = {};  // V14: per-day active/idle/off
  var workerStats = {};     // V14: worker count breakdown
  
  var directDailyAgg = {};
  var directMaterialNetto = {};
  var directTruckTypes = {};
  var directTotalNetto = 0;
  var directTotalTrucks = 0;
  
  for (var i = 0; i < rawData.length; i++) {
    var rawMat = (rawData[i][9] || "").toString().trim().toUpperCase();
    if(rawMat) materials.add(rawMat);
    
    var rowDate = parseDate(rawData[i][0]);
    if (!rowDate) continue;
    
    var m = rowDate.getMonth() + 1;
    var y = rowDate.getFullYear();
    if (targetMonth && targetYear) {
      if (m !== targetMonth || y !== targetYear) continue;
    }
    if (matFilter && rawMat.indexOf(matFilter) !== 0) continue;
    
    var dateKey = Utilities.formatDate(rowDate, "GMT+7", "yyyy-MM-dd");
    var rowNetto = parseNetto(rawData[i][8]);
    var type = (rawData[i][1] || "").toUpperCase();
    var truckType = (rawData[i][6] || "").toString().trim().toUpperCase() || "UNKNOWN";
    
    // ---- Material & truck type breakdowns (V7.4) ----
    if (rawMat) { materialNetto[rawMat] = (materialNetto[rawMat] || 0) + rowNetto; }
    
      // ---- Global Daily aggregation ----
    if (!dailyAgg[dateKey]) {
      dailyAgg[dateKey] = {
        date: dateKey, netto: 0, trucks: 0, cycleMin: 0,
        intakeNetto: 0, directNetto: 0,
        shiftData: {
          "1": { sbm_ins: 0, sbm_dg: 0, pkm_ins: 0, pkm_dg: 0, active: 0, qc: 0, man: 0, idle: 0, off: 0, workers: 0, trucks: 0 },
          "2": { sbm_ins: 0, sbm_dg: 0, pkm_ins: 0, pkm_dg: 0, active: 0, qc: 0, man: 0, idle: 0, off: 0, workers: 0, trucks: 0 },
          "3": { sbm_ins: 0, sbm_dg: 0, pkm_ins: 0, pkm_dg: 0, active: 0, qc: 0, man: 0, idle: 0, off: 0, workers: 0, trucks: 0 }
        }
      };
    }
    var d = dailyAgg[dateKey];
    d.netto += rowNetto;
    d.trucks++;
    if (type.indexOf("INTAKE") !== -1) d.intakeNetto += rowNetto;
    else d.directNetto += rowNetto;
    
    var pt_m = parseTime(rawData[i][13]);
    var pb_m = parseTime(rawData[i][16]);
    
    // V11.4: Use only PB (Proses Bongkar) for duration
    var rowDur = pb_m;
    d.cycleMin += rowDur;

    // --- NEW SHIFT BREAKDOWN LOGIC (V15) ---
    var endTs = rawData[i][15]; // Bongkar Selesai
    var startTs = rawData[i][14]; // Bongkar Mulai
    var actualShift = (rawData[i][4] || "").toString(); // Col E
    
    if (endTs instanceof Date && !isNaN(endTs.getTime())) {
      var h = endTs.getHours();
      var m = endTs.getMinutes();
      var timeTotal = h + (m/60);
      // Shift 1: 07:01 - 15:00, Shift 2: 15:01 - 23:00, Shift 3: Else
      if (timeTotal > 7 && timeTotal <= 15) actualShift = "1";
      else if (timeTotal > 15 && timeTotal <= 23) actualShift = "2";
      else actualShift = "3";
    } else {
      // Logic for shift based on Col E if no finish time
      if (actualShift.includes("1")) actualShift = "1";
      else if (actualShift.includes("2")) actualShift = "2";
      else if (actualShift.includes("3")) actualShift = "3";
      else actualShift = "1"; // Default
    }
    
    var sd = d.shiftData[actualShift] || d.shiftData["1"]; // Fallback
    sd.trucks++;
    var rowWorkers = parseInt(rawData[i][23]) || 0; // Col X
    sd.workers += rowWorkers;

    var isI71 = (type.indexOf("INTAKE 71") !== -1);
    var isDG = (type.indexOf("DIRECT GUDANG") !== -1);

    if (rawMat.indexOf("SBM") !== -1) {
      if (isI71) sd.sbm_ins += rowNetto;
      else if (isDG) sd.sbm_dg += rowNetto;
    } else if (rawMat.indexOf("PKM") !== -1) {
      if (isI71) sd.pkm_ins += rowNetto;
      else if (isDG) sd.pkm_dg += rowNetto;
    }
    
    // V11.9: Strict Path & synchronized logic
    if ((isI71 || isDG) && truckType && truckType !== "UNKNOWN") {
      var targetColl = isI71 ? intakeTruckTypes : directTruckTypes;
      
      if (!targetColl[truckType]) {
        targetColl[truckType] = { trucks: 0, netto: 0, duration: 0, min: 9999, max: 0, validDurCount: 0 };
      }
      var tts = targetColl[truckType];
      tts.trucks++; 
      tts.netto += rowNetto;
      
      // V11.8+11.9: Strict non-zero handling for Min/Avg
      if (rowDur > 0) {
        tts.duration += rowDur;
        tts.validDurCount++;
        if (rowDur < tts.min) tts.min = rowDur;
        if (rowDur > tts.max) tts.max = rowDur;
      }
    }

    // ---- INTAKE 71 specific with V12 Logic ----
    if (isI71) {
      if (startTs instanceof Date && endTs instanceof Date && !isNaN(startTs.getTime()) && !isNaN(endTs.getTime())) {
        var day = rowDate.getDate();
        var absStart = ((day - 1) * 24 * 60) + (startTs.getHours() * 60) + startTs.getMinutes() + (startTs.getSeconds() / 60);
        var absEnd = ((day - 1) * 24 * 60) + (endTs.getHours() * 60) + endTs.getMinutes() + (endTs.getSeconds() / 60);
        
        var duration = absEnd - absStart;
        if (duration > 0 && duration < 600) {
          i71TotalNetto += rowNetto;
          i71TruckCount++;
          
          // V13.2: BULLETPROOF Manuver/QC parsing
          var rowMan = 0;
          var rowQC = 0;
          var manS = rawData[i][17];
          var manE = rawData[i][18];
          if (manS instanceof Date && manE instanceof Date && !isNaN(manS.getTime()) && !isNaN(manE.getTime())) {
            var manDiff = ((manE.getHours() * 60) + manE.getMinutes() + (manE.getSeconds() / 60)) -
                          ((manS.getHours() * 60) + manS.getMinutes() + (manS.getSeconds() / 60));
            if (manDiff > 0 && manDiff < 600) rowMan = manDiff;
          }
          var qcS = rawData[i][20];
          var qcE = rawData[i][21];
          if (qcS instanceof Date && qcE instanceof Date && !isNaN(qcS.getTime()) && !isNaN(qcE.getTime())) {
            var qcDiff = ((qcE.getHours() * 60) + qcE.getMinutes() + (qcE.getSeconds() / 60)) -
                         ((qcS.getHours() * 60) + qcS.getMinutes() + (qcS.getSeconds() / 60));
            if (qcDiff > 0 && qcDiff < 600) rowQC = qcDiff;
          }
          var manQcSum = rowMan + rowQC;
          if (manQcSum > duration && manQcSum > 0) {
            var scale = duration / manQcSum;
            rowMan = rowMan * scale;
            rowQC = rowQC * scale;
          }
          
          i71TotalMan += rowMan;
          i71TotalQC += rowQC;
          i71ActiveTotalGenerated += duration;

          // Add to shift dur
          sd.active += duration;
          sd.qc += rowQC;
          sd.man += rowMan;
          
          var truckSpeed = duration > 0 ? (rowNetto / 1000) / (duration / 60) : 0;
          if (truckSpeed > 0) {
            if (truckSpeed < i71MinSpeed) i71MinSpeed = truckSpeed;
            if (truckSpeed > i71MaxSpeed) i71MaxSpeed = truckSpeed;
            i71TotalSpeedSum += truckSpeed;
            i71SpeedValidCount++;
          }
          
          if (rawMat) { i71MaterialNetto[rawMat] = (i71MaterialNetto[rawMat] || 0) + rowNetto; }
          
          intake71Trucks.push({ 
            start: absStart, end: absEnd, mat: rawMat, day: day, shift: actualShift,
            code: (rawData[i][10] || "").toString().trim().toUpperCase() 
          });
          
          // V14: Intake sub-type (TILTING vs MANUAL)
          var subType = (rawData[i][1] || "").toString().toUpperCase().indexOf("TILTING") !== -1 ? "TILTING" : "MANUAL";
          if (!intakeSubTypes[subType]) intakeSubTypes[subType] = { trucks: 0, netto: 0, duration: 0 };
          intakeSubTypes[subType].trucks++;
          intakeSubTypes[subType].netto += rowNetto;
          intakeSubTypes[subType].duration += duration;
          
          // V14: Daily detail for intake
          if (!i71DailyDetail[dateKey]) i71DailyDetail[dateKey] = { date: dateKey, netto: 0, trucks: 0, activeMin: 0 };
          i71DailyDetail[dateKey].netto += rowNetto;
          i71DailyDetail[dateKey].trucks++;
          i71DailyDetail[dateKey].activeMin += duration;
          
          // V14: Worker count stats (col 23)
          var wCount = parseInt(rawData[i][23]) || 0;
          if (wCount > 0) {
            var wKey = wCount.toString();
            if (!workerStats[wKey]) workerStats[wKey] = { count: wCount, totalNetto: 0, trucks: 0, totalDur: 0 };
            workerStats[wKey].totalNetto += rowNetto;
            workerStats[wKey].trucks++;
            workerStats[wKey].totalDur += duration;
          }
        }
      }
    }
    
    // ---- DIRECT GUDANG collectors (V7.4) ----
    if (isDG) {
      directTotalNetto += rowNetto;
      directTotalTrucks++;
      if (rawMat) { directMaterialNetto[rawMat] = (directMaterialNetto[rawMat] || 0) + rowNetto; }
      
      if (!directDailyAgg[dateKey]) {
        directDailyAgg[dateKey] = { date: dateKey, netto: 0, trucks: 0 };
      }
      var dd = directDailyAgg[dateKey];
      dd.netto += rowNetto;
      dd.trucks++;
    }
  }
  
  // ======== INTAKE 71 FAST NORMALIZATION LOGIC (V14.0) ========
  var now = new Date();
  var daysInMonth = new Date(targetYear, targetMonth, 0).getDate();
  var totalMonthMin;
  if (now.getFullYear() === targetYear && (now.getMonth() + 1) === targetMonth) {
    totalMonthMin = ((now.getDate() - 1) * 1440) + (now.getHours() * 60) + now.getMinutes();
  } else {
    totalMonthMin = daysInMonth * 1440;
  }
  
  var idleMin = 0;
  var offMin = 0;
  
  if (intake71Trucks.length > 0) {
    intake71Trucks.sort(function(a, b) { return a.start - b.start; });
    
    // 1. Initial Gap Analysis (Procedural & Fast)
    offMin += intake71Trucks[0].start; // Before first truck
    
    for (var j = 0; j < intake71Trucks.length - 1; j++) {
      var curr = intake71Trucks[j];
      var next = intake71Trucks[j+1];
      var gap = next.start - curr.end;
      if (gap > 0) {
        if (curr.mat === next.mat && curr.code === next.code) idleMin += gap;
        else offMin += gap;
      }
    }
    
    var lastEnd = intake71Trucks[intake71Trucks.length - 1].end;
    if (totalMonthMin > lastEnd) offMin += (totalMonthMin - lastEnd);
  } else {
    offMin = totalMonthMin;
  }

  // 2. CRITICAL FIX: Mathematical Normalization (V14.0)
  // If (Active + Idle + Off) > total calendar time, scale the gaps down.
  // This is the FAST way to lock duration to 24h without heavy loops.
  var rawTotal = i71ActiveTotalGenerated + idleMin + offMin;
  var finalActive = i71ActiveTotalGenerated;
  var finalIdle = idleMin;
  var finalOff = offMin;

  if (rawTotal > totalMonthMin) {
    var leftover = Math.max(0, totalMonthMin - finalActive);
    var gapRatio = (idleMin + offMin) > 0 ? (idleMin / (idleMin + offMin)) : 0.5;
    finalIdle = leftover * gapRatio;
    finalOff = leftover - finalIdle;
  }

  // 3. Simple Shift Distribution (Capped at 480)
  Object.values(dailyAgg).forEach(function(d) {
    ["1", "2", "3"].forEach(function(s) {
      var sd = d.shiftData[s];
      sd.active = Math.min(480, sd.active);
      var rem = 480 - sd.active;
      // Proportional split for this shift
      var sRatio = (finalIdle + finalOff) > 0 ? (finalIdle / (finalIdle + finalOff)) : 0.5;
      sd.idle = Math.round(rem * sRatio);
      sd.off = 480 - sd.active - sd.idle;
    });
  });

  // Build daily detail
  var i71DailyArr = [];
  Object.keys(i71DailyDetail).forEach(function(dk) {
    var dd = i71DailyDetail[dk];
    var dObj = dailyAgg[dk];
    if (dObj) {
      var sh = dObj.shiftData;
      dd.activeMin = sh["1"].active + sh["2"].active + sh["3"].active;
      dd.idleMin = sh["1"].idle + sh["2"].idle + sh["3"].idle;
      dd.offMin = sh["1"].off + sh["2"].off + sh["3"].off;
      dd.tonPerHour = dd.activeMin > 0 ? (dd.netto / 1000) / (dd.activeMin / 60) : 0;
    }
    i71DailyArr.push(dd);
  });
  i71DailyArr.sort(function(a,b) { return a.date.localeCompare(b.date); });
  
  var intake71 = {
    activeTotal: Math.round(finalActive),
    netDischarge: Math.round(Math.max(0, finalActive - i71TotalMan - i71TotalQC)),
    manuverTotal: Math.round(i71TotalMan),
    qcTotal: Math.round(i71TotalQC),
    idleLoss: Math.round(finalIdle),
    offSetup: Math.round(finalOff),
    activePct: (finalActive / totalMonthMin) * 100,
    trucks: i71TruckCount,
    nettoKg: Math.round(i71TotalNetto),
    materials: i71MaterialNetto,
    avgSpeed: i71SpeedValidCount > 0 ? (i71TotalSpeedSum / i71SpeedValidCount) : 0,
    minSpeed: i71MinSpeed === 9999 ? 0 : i71MinSpeed,
    maxSpeed: i71MaxSpeed,
    totalMonthMin: totalMonthMin,
    intakeSubTypes: intakeSubTypes,
    dailyDetail: i71DailyArr,
    workerStats: workerStats
  };
  
  // ======== BUILD RESULT (PRESERVED) ========
  var result = Object.values(dailyAgg).sort(function(a,b) { return a.date.localeCompare(b.date); }).map(function(s) {
    return {
      date: s.date,
      netto: Math.round(s.netto),
      trucks: s.trucks,
      avgCycle: s.cycleMin / s.trucks,
      dist: { 
        intake: Math.round((s.intakeNetto / s.netto) * 100) || 0, 
        direct: Math.round((s.directNetto / s.netto) * 100) || 0 
      },
      shiftData: s.shiftData // V15: Detailed shift analysis
    };
  });
  
  var directDaily = Object.keys(directDailyAgg).sort().map(function(k) {
    var s = directDailyAgg[k];
    return { date: s.date, netto: Math.round(s.netto), trucks: s.trucks };
  });

  return createOutput({
    status: "success",
    data: result,
    materialBreakdown: materialNetto,
    truckTypes: intakeTruckTypes, // V11.5: Specifically Intake
    intake71: intake71,
    directGudang: {
      totalNetto: Math.round(directTotalNetto),
      totalTrucks: directTotalTrucks,
      daily: directDaily,
      materials: directMaterialNetto,
      truckTypes: directTruckTypes // V11.5: Specifically Direct
    },
    materials: Array.from(materials).sort()
  }, e);
}

function getOutstandingBKKTurbo(ssId, e) {
  var ss = SpreadsheetApp.openById(ssId);
  var sheet = ss.getSheetByName("Monitoring bongkaran");
  var allValues = sheet.getRange(1, 1, 250, 9).getValues();

  var intakeData = [
    { name: allValues[1][1], status: allValues[2][1], material: allValues[3][1] },
    { name: allValues[1][2], status: allValues[2][2], material: allValues[3][2] }
  ];

  var silos = [];
  for (var col = 0; col < 6; col++) {
    var c = 3 + col; 
    silos.push({
      id: ["BK1","BK2","BK3","BK4","BK5","BK6"][col], 
      material: allValues[6][c], vessel: allValues[7][c], 
      stock: allValues[8][c], percentage: allValues[9][c],
      age: allValues[10][c], status: allValues[13][c]
    });
  }

  var truckData = [];
  for (var i = 21; i < allValues.length; i++) {
    if (!allValues[i][2] && !allValues[i][3]) continue; 
    truckData.push({
      material: allValues[i][2], netto: allValues[i][4], type: allValues[i][5], aging: allValues[i][7],
      nopol: (allValues[i][3] || "").toString().split(/\d{2}[-./]/)[1]?.trim() || allValues[i][3]
    });
  }

  return createOutput({ intake: intakeData, silos: silos, trucks: truckData }, e);
}

function createOutput(result, e) {
  var jsonString = JSON.stringify(result);
  var cb = (e && e.parameter && e.parameter.callback) ? e.parameter.callback : null;
  if (cb) {
    return ContentService.createTextOutput(cb + "(" + jsonString + ")")
      .setMimeType(ContentService.MimeType.JAVASCRIPT);
  } else {
    return ContentService.createTextOutput(jsonString).setMimeType(ContentService.MimeType.JSON);
  }
}
